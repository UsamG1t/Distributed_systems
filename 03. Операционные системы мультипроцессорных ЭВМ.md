Для мультипроцессорных ЭВМ настройка взаимодействия отдельных его компонентов была одной из первостепенных задач, с которой столкнулись инженеры и программисты. Начальным вопросом, конечно, стояла организация операционной системы. Два классических решения этой задачи - создание `master-slave` схемы, при которой один из процессоров полностью выделяется для ОС, и `симметричная` схема, распределяющая управляющие процессы по всей системе. Первая крайне просто реализовывалась, однако обладала ярко выраженным узким местом с точки зрения загруженности и надёжности. Вторая же была наиболее эффективна для работы, но была сложна в реализации и дальнейшей отладке.

# Процессы и нити

Исполняющей единицей в любой операционной системе выступает ***Процесс*** - совокупность машинных команд и данных, обладающая правом доступа к некоторым ресурсам ВС. Традиционно, процесс имеет собственное адресное пространство и его состояние характеризуется следующей информацией: 
 + Таблицы страниц (или сегментов);
 + Дескрипторы файлов;
 + Заказы на ввод-вывод;
 + Регистры; 
и т.п. Большой объем этой информации делает дорогими работу процессов, их переключение.

Потребность в легковесных процессах - ***нитях*** (`threads`), которые совместно используют единое адресное пространство процесса, возникла еще на однопроцессорных ЭВМ (физические процессы или их моделирование, совмещение обменов и счета), но для использования достоинств многопроцессорных ЭВМ с общей памятью (а в дальнейшем - в локальных машинах распределённой системы) они просто необходимы.

# Взаимодействие процессов

В рамках единой системы различные процессы могут быть **независимыми**, т.е. не требовать какой-либо синхронизации и обмена информацией (но конкурировать за ресурсы), или **взаимодействующими**. 

Если приложение подразумевает взаимодействие процессов или нитей, то классически оно осуществляется двумя основными способами:
 + Посредством разделения памяти (оперативной или внешней);
 + Посредством передачи сообщений

Про передачу сообщений мы поговорим в следующей главе, сейчас подробно обсудим разделение памяти и методы взаимодействия при нём.

При взаимодействии через общую память процессы должны синхронизовать свое выполнение (справедливости ради, синхронизация происходит во всех случаях: ограничение и контроль доступа к памяти это **синхронизация работы**, приём-передача сообщений это **синхронизация данных**. Здесь под словом `синхронизация` будем иметь в виду синхронизацию работы).\ 
Различают два вида синхронизации - ***взаимное исключение критических интервалов***(`ВИКИ`) и ***координация процессов***. ***Критические секции*** – частный случай критического интервала, когда критический интервал оформлен в виде конструкции языка программирования. 

## Взаимное исключение критических интервалов

### Зачем и как?

Если в системе не обеспечить взаимное исключение критических интервалов, то мы столкнёмся с классическими проблемами многопроцессных программ - недетерминизмом, гонками за ресурс, блокировками (`deadlock`) и т.д.\
Классический пример, где результат будет зависеть от порядка выполнения команд:

| Команда      | X = X + 1                                       | X = X - 1                                       |
| ------------ | ----------------------------------------------- | ----------------------------------------------- |
| Машинный код | `Load R1, X`<br>`Add R1, ="1"`<br>`Store R1, X` | `Load R1, X`<br>`Sub R1, ="1"`<br>`Store R1, X` |

Взаимное исключение представляет собой алгоритм взаимодействия процессов, удовлетворяющий ***нескольким требованиям***:
 + **В любой момент времени только один процесс может находиться внутри критического интервала** (Да, формально доступ нескольких процессов, пусть и контролируемый нами, это уже не взаимное исключение (оно и логично, как бы), хотя и такие примеры мы дальше будем упоминать);
 + **Если ни один процесс не находится в критическом интервале, то любой процесс, желающий войти в критический интервал, должен получить разрешение без какой-либо задержки;**
 + **Ни один процесс не должен бесконечно долго ждать разрешения на вход в критический интервал (если, конечно, ни один процесс не будет находиться внутри критического интервала бесконечно долго);**
 + **Не должно существовать никаких предположений о скоростях процессоров, на которых выполняются процессы.**

В **однопроцессорных системах** `ВИКИ` достигается путём **блокировки внешних прерываний** (помним: внутренние, которые срабатывают при делении на ноль или при работе с виртуальной памятью, продолжают работать, это просто внутренние процессы работы процесса (хехе); мы именно перехват управления блокируем) и **блокировка переключения между процессами**.\
В многопроцессорных системах `ВИКИ` основано на идее неделимости операций записи и чтения из памяти (При чтении переменной всегда читается последнее присвоенное ей значение)

### Алгоритмы активного ожидания

При работе с общей памятью при обеспечении неделимых операций чтения-записи возможно организовать **алгоритмы активного ожидания**, постоянно проверяющие состояние переменных в цикле. Классическими примерами таких алгоритмов выступают **алгоритм Деккера (1968)**, **Алгоритм Петерсона (1981)**, а также низкоуровневый алгоритм на основе операции `TSL` - `TEST_and_SET_LOCK`

`Алгоритм Деккера (для двух процессов):`
```python
turn = 0 # or 1
flag = [False, False]

def enter_region(i: int) -> None:
	flag[i] = True
	while flag[1 - i] = True:
		if turn == 1 - i:
		    flag[i] = False
	        while turn == 1 - i:
		        pass
	        
		    flag[0] = True

def leave_region(i: int) -> None:
	turn = 1 - i
	flag[i] = False
```

`Алгоритм Петерсона (для двух процессов):`
```python
turn = 0 # or 1
flag = [False, False]

def enter_region(i: int) -> None:
	flag[i] = True
	turn = i
	while turn == i and flag[1 - i] == True:
		pass

def leave_region(i: int) -> None:
	flag[i] = False
```

`TSL(r, s) - НЕДЕЛИМАЯ`
```python
	r = s
	s = 1
```

`TSL-algo`
```asm
enter_region:
	tsl reg, flag
	cmp reg, 0
	jnz .enter_region
	ret

leave_region:
	mov flag, 0
	ret
```

Очевидные недостатки "активного ожидания" при использовании команды `TSL` или алгоритмов Деккера или Петерсона - бесполезная трата времени, нагрузка на общую память, и возможность фактически заблокировать работу процесса, находящегося в критическом интервале. Избежать активного ожидания помогают **семафоры**.

### Семафоры Дейкстры (1965)

***Семафор*** - неотрицательная целая переменная,  которая может изменяться и
проверяться только посредством **двух атомарных$^1$ операций**:

 + Функция запроса семафора P(s):
	```python
	if s == 0:
		<заблокировать текущий процесс>
	else:
		s -= 1
	```
 + Функция освобождения семафора V(s):
	```python
	if s == 0:
		<разблокировать один из заблокированных процессов>
	s += 1
	```

В общем случае (и в реальности) семафоры считающие (против двоичного формализма Дейкстры).

#### Куча примеров:

 + `Задача "Производитель-Потребитель" в условиях ограниченного буфера:`
```c
semaphore s = 1;
semaphore full = 0;
semaphore empty = N;

void producer() {
	int item;
	
	while (TRUE) {
		produce_item(&item);
		P(empty);
		P(s);
		enter_item(item);
		V(s);
		V(full);
		consume_item(item);
	}
}

void consumer() {
	int item;
	while (TRUE) {
		P(full);
		P(s);
		remove_item(&item);
		V(s);
		V(empty);
	}
}
```

 + `Задача "Обедающие философы":`
```c
#define N 5 /* количество философов */
#define LEFT (i-1)%N /* номер левого соседа для i-го
философа */
#define RIGHT (i+1)%N /*номер правого соседа для i-го
философа*/

/* состояния философов: «думает», «голоден»,
«кушает»*/
#define THINKING 0
#define HUNGRY 1
#define EATING 2

/*массив состояний каждого из философов,
инициализированный нулями*/
int state[N];

/* семафор для доступа в критическую секцию */
semaphore mutex = 1;

/*массив семафоров по одному на каждого из
философов, инициализированный нулями*/
semaphore s[N];

/* Процесс-философ (i = 0..N-1) */
void Philosopher(int i) {
	while(TRUE) {
		Think();
		TakeForks(i); /* философ берёт обе вилки или блокируется */
		Eat();
		PutForks(i);
	}
}

/* получение вилок */
void TakeForks(int i) {
	/* вход в критическую секцию */
	down(&mutex);
	state[i] = HUNGRY;
	Test(i);
	/* выход из критической секции */
	up(&mutex);
	down(&s[i]);
}

/* освобождение вилок */
void PutForks(int i) {
	/* вход в критическую секцию */
	down(&mutex);
	state[i] = THINKING;
	Test(LEFT);
	Test(RIGHT);
	/* выход из критической секции */
	up(&mutex);
}

/* функция проверки возможности получения вилок –
проверяется состояние соседей данного философа */
void Test(int i) {
	if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {
		state[i] = EATING;
		up(&s[i]);
	}
}
```

 + `Задача "Читатели и Писатели":`
```c
/* семафор для доступа в критическую секцию -
контроль за доступом к «rc» (разделямый ресурс) */
semaphore mutex = 1;

/* семафор для доступа к базе данных */
semaphore db = 1;

/* количество читателей внутри хранилища */
int rc = 0;

/* процесс-писатель */
void Writer(void) {
	ThinkUpData(); /* некритическая секция */
	down(&db); /* получить эксклюзивный доступ к данным*/
	WriteDataBase(); /* записать данные */
	up(&db); /* отдать эксклюзивный доступ */
}

/* процесс-читатель */
void Reader(void) {
	down(&mutex); /* получить эксклюзивный доступ к «rc»*/
	rc = rc + 1; /* еще одним читателем больше */

	/*первый читатель - заблокировать доступ к базе */
	if(rc == 1) {
		down(&db);
	}
	up(&mutex); /*освободить ресурс rc */

	ReadDataBase(); /* доступ к данным */

	down(&mutex); /*получить эксклюзивный доступ к «rc»*/
	rc = rc – 1; /* теперь одним читателем меньше */

	/*последний читатель - разблокировать доступ к базе*/
	if(rc == 0) {
		up(&db);
	}
	up(&mutex); /*освободить разделяемый ресурс rc*/

	UseDataRead(); /* некритическая секция */
}
```

 + `Задача "Спящий Парикмахер":`
```c
/* количество стульев в комнате ожидания */
#define CHAIRS 5

/* наличие посетителей, ожидающих парикмахера */
semaphore customers = 0;

/* состояние парикмахера: спит/занят или готов к работе (0 или 1) ; В принципе возможно расширение задачи для случая N парикмахеров, в этом случае, с незначительными коррекциями программ, barbers – количество свободных парикмахеров.*/
semaphore barbers = 0;

/* семафор для доступа в критическую секцию - контроль задоступом к переменной waiting */
semaphore mutex = 1;

/* количество ожидающих посетителей */
int waiting = 0;

/* Брадобрей */
void Barber(void) {
	while(TRUE) {
		down(&customers); /* если customers == 0, т.е. посетителей нет, то заблокируемся до появления посетителя */
		down(&mutex); /* получаем доступ к waiting */
		waiting = waiting – 1;/* уменьшаем кол-во ожидающих клиентов */
		up(&barbers); /* парикмахер готов к работе */
		up(&mutex); /* освобождаем ресурс waiting */
		CutHair(); /* процесс стрижки */
	}
}

/* Посетитель */
void Customer(void) {
	down(&mutex); /* получаем доступ к waiting */
	if(waiting < CHAIRS) { /* есть место для ожидания */
		waiting = waiting + 1; /* увеличиваем кол-во ожидающих клиентов */
		up(&customers); /* если парикмахер спит, это его разбудит */
		up(&mutex); /* освобождаем ресурс waiting */
		down(&barbers);/* если парикмахер занят, переходим в состояние ожидания, иначе – занимаем парикмахера */
		GetHaircut(); /* занять место и перейти к стрижке */
	} else { /*нет свободного кресла для ожидания – придется уйти */
		up(&mutex);
	}
}
```


## Координация процессов

Для работы в ***мультипрограммном режиме*** в `многопроцессорных ЭВМ` блокировка внешних прерываний и запрет переключения на другие процессы  не годятся. Остаётся способ **использования переменной и очереди ожидающих процессов в ОС**. Для его реализации  достаточно команды `TSL` и возможности объявлять прерывание указанному _процессору_ (чтобы сообщить другим процессорам, что разблокирован один из _процессов_) {не путать **процессы** и **процессоры**}. Работа с семафорами упрощает это взаимодействие (убирает активное ожидание), однако если семафор захватывается на очень короткое время, блокирование процесса и переключение на другой становятся неэффективными. Можно ввести специальные семафоры, которые захватываются на короткое время (ожидание освобождения таких семафоров может быть реализовано в ОС посредством циклического опроса значения семафора), однако и это сильно замедлит работу системы, особенно когда на ключевые действия системы синхронизированы не один, а несколько процессов.

### События

Если произведенный объект или действие используется многими или влияет на многие процессы, то семафоры не годятся. ***События*** - это переменные, показывающие, что произошли определенные действия.

Для объявления события служит оператор `POST(<имя_переменной>)`, для ожидания события (с блокировкой) - `WAIT(<имя_переменной>)`. Для чистки (присваивания нулевого значения) - оператор `CLEAR(<имя_переменной>)`. Возможны разные варианты реализации событийных переменных.  **Не хранящие информацию** по оператору `POST` выводят из ожидания только те процессы, которые уже выдали `WAIT` и непосредственно ждут разблокировку (`CLEAR` для таких не нужен), **хранящие информацию события** просто открывают доступ к дальнейшему исполнению программы любому процессу, приходящему к событию. 

***Пример:*** Метод последовательной верхней релаксации (`SOR`) с использованием массива событий. В нем для вычисления элемента матрицы $\textrm{A[i][j]}$ требуется
предварительно вычислить элементы $\textrm{A[i-1][j]}$ и $\textrm{A[i][j-1]}$. Нулевая строка и
нулевой столбец матрицы заданы изначально и не вычисляются. Заголовок
цикла `parfor` означает, что витки цикла можно выполнять параллельно.

```c
float A[L1][L2];
struct event s[L1][L2];

for (int i = 0; i < L1; i++) {
	for (int j = 0; j < L2; j++) {
		clear(s[i][j]);
	}
}

for (int j = 0; j < L2; j++) {
	post(s[0][j])
}

for (int i = 0; i < L1; i++) {
	post( s[i][0])
}

parfor (int i = 1; i < L1-1; i++) {
	parfor (int j = 1; j < L2-1; j++) {
		wait(s[i-1][j]);
		wait(s[i][j-1]);
		A[i][j] = (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]) / 4;
		post(s[i][j]);
	}
}

```


### Планирование процессоров

Не одними ограничивающими механизмами достигается  эффективное взаимодействие **процессов** (опять же не путаем слова). На уровне железа также есть свои способы улучшения работы мультипроцессорных систем. Планирование процессоров очень сильно влияет на производительность мультипроцессорной системы. 

Главных причин деградации производительности системы две: 
 + ***Накладные расходы на переключение процессора.*** Они определяются не только переключениями контекстов процессов, но и (при переключении на процессы другого приложения) перемещениями страниц виртуальной памяти, а также порчей кэша (информация в кэше другому приложению не нужна и будет заменена). 
 + ***Неконтролируемое переключение на другой процесс.*** Имеется в виду тот момент, когда текущий процесс выполнял критическую секцию, а другие процессы активно ожидают входа в критическую секцию. В этом случае потери будут велики (хотя вероятность прерывания выполнения коротких критических секций мала).

Путём грамотного планирования можно уменьшить или вовсе избежать деградации производительности. Вот некоторые стратегии планирования, помогающие справиться с этими проблемами: 
 + ***Совместное планирование***, при котором все процессы одного приложения (неблокированные) одновременно выбираются на процессоры и одновременно снимаются с них (для сокращения переключений контекста). 
 + ***Планирование***, при котором находящиеся ***в критической секции процессы не прерываются***, а активно ожидающие входа в критическую секцию процессы не выбираются до тех пор, пока вход в секцию не освободится. 
 + ***Процессы планируются на те процессоры, на которых они выполнялись в момент их снятия*** (для борьбы с порчей кэша). При этом может нарушаться балансировка загрузки процессоров. 
 + ***Планирование с учетом "советов" программы*** (во время ее выполнения). В ОС Mach имеется два класса таких советов (hints) - указания (разной степени категоричности) о снятии текущего процесса с процессора, а также указания о том процессе, который должен быть выбран взамен текущего.


---

# Дополнения

## 1. Уточнение терминологии

***Атомарными*** называются операции, действие которых невозможно отследить в промежуточном состоянии: в любой момент времени операция или **вообще не исполнена**, или **полностью завершена**.

Такой формализм нужен, потому что, вообще говоря, прервать атомарную операцию можно (н-р, во время исполнения дёрнуть курсором - движение мыши будет засечено и прерывание с информацией об этом в систему придёт), просто само промежуточное состояние операции поймать не получится