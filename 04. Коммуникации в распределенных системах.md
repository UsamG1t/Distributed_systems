
Идея избавиться (правильнее сказать, дополнить ещё одним способом взаимодействия) от синхронизации процессов **по работе** и прийти к синхронизации **по данным** не новая. Первое широкое распространение идей приёма-передачи сообщений было описано в работе Чарльза Энтони Ричарда Хоара "Взаимодействующие последовательные процессы" 1978 года. Его целью было избавиться от проблем разделения памяти и предложить модель
взаимодействия процессов для распределенных систем, основанную на двух ключевых операциях:
 + `send (destination, &message, msize);`
 + `receive ([source], &message, msize);`

С помощью передачи собщений можно решать уже известные нам задачи синхронизации, например, задачу "Производитель-Потребитель":

```c
#define N 100 /* максимальное число сообщений в буфере */
#define msize 4 /* размер сообщения */

void producer() {
	message[msize] m;
	message[msize] item;

	while (TRUE) {
		produce_item(&item);
		receive(consumer, &m, msize); /* получает пустой "контейнер" */
		build_message(&m, item); /* формирует сообщение */
		send(consumer, &m, msize);
	}
}

void consumer() {
	message[msize] m;
	message[msize] item;
	int i;
	
	for (i = 0; i < N; i ++) {
		send(producer, &m, msize); /* посылает все пустые "контейнеры" */
	}

	while (TRUE) {
		receive(producer, &m, msize);
		extract_item(&m, item);
		send(producer, &m, msize); /* возвращает "контейнер" */
		consume_item(item);
	}
}
```

Механизмы семафоров и обмена сообщениями взаимозаменяемы семантически и на мультипроцессорах могут быть реализованы один через другой (В ту же дружную компанию можно вписать и события, которые тоже прекрасно через семафоры (и транзитивно через сообщения) реализуются).

---

Развитие систем взаимодействия процессов от передачи сообщений близкородственными процессами (например, неименованные каналы) до межсетевого взаимодействия (известный нам механизм сокетов) и далее ведут нас к упрощению в управлении и синхронизации работы больших (как по данным, так и по исполняющим потокам) систем. Вот упрощённая схема известных нам методов взаимодействия процессов:

![](Attached_materials/Process_Interactions.png)

В этой главе нас будут интересовать коммуникационные сети и взаимодействие в них.  Коммуникационные сети подразделяются на **широкомасштабные** (`Wide Area Networks`, `WANs`) и **локальные** (`Local Area Networks`, `LANs`).

# Широкомасштабные сети

`WAN` состоит из коммуникационных ЭВМ, связанных между собой коммуникационными линиями (телефонные линии, радиолинии, спутниковые каналы, оптоволокно) и обеспечивающих транспортировку сообщений. Для сети характерна техника передачи `store-and-forward`, когда сообщения передаются из одного компьютера в следующий с промежуточной буферизацией. Связано это с потенциально большими потерями данных при передаче в `WAN` из-за больших расстояний и множественных изменений формата передачи.

## Коммутация пакетов или коммутация линий. 

Из курса Сетей мы знаем, что при передаче данных используется два способа соединения пользователей - **коммутация линий** и **коммутация пакетов**. \
*Коммутация линий* (телефонные разговоры) требует резервирования линий на время всего сеанса общения двух устройств. *Пакетная коммутация* основана на разбиении сообщений в пункте отправления на порции (пакеты), посылке пакетов по адресу назначения, и сборке сообщения из пакетов в пункте назначения. При этом линии используются эффективнее, сообщения могут передаваться быстрее, но требуется работа по разбиению и сборке сообщений, а также возможны задержки (для передачи медиафайлов или речи такой метод не годится).

## Семиуровневая модель `ISO/OSI`

`ISO OSI` (`International Standards Organizations»s Reference Model of Open Systems Interconnection`) организует коммуникационные протоколы в виде семи уровней и специфицирует функции каждого уровня.

Уровни этой модели располагаются от физической среды передачи данных до прикладного уровня. Gри этом предполагается, что взаимодействие в сети может осуществляться между одноимёнными (одноранговыми) уровнями. для осуществления этого взаимодействия используются протоколы. 

$$Дальше\ кусок\ текста\ из\ ОСей.$$ $$Можно\ его\ пропустить,\ это\ чисто\ для\ вспоминания\ раздел$$

***Протокол*** — это формальное описание сообщений и правил, по которым сетевые устройства (вычислительные системы) осуществляют обмен информацией. Таким образом, протокол обеспечивает взаимодействие в сети между различными сетевыми устройствами на одноимённых уровнях. Любой из уровней может содержать произвольное число протоколов, но общаться могут лишь протоколы одного уровня. Также под протоколом будут пониматься правила взаимодействия одноименных, или одноранговых, уровней. \
***Интерфейс*** — правила взаимодействия вышестоящего уровня с нижестоящим. \
***Служба*** или ***сервис*** — набор операций, предоставляемых нижестоящим уровнем вышестоящему. \
***Стек протоколов*** — перечень разноуровневых (от первого до максимального реализованного) протоколов, реализованных в системе. стек может быть произвольной глубины, т.е. в нем, возможно, не будут представлены протоколы некоторых уровней модели `iso/osi`. 

При осуществлении взаимодействия информация должна быть сначала передана с текущего на первый уровня на данном сетевом устройстве, затем передана по коммуникационной среде, принята на другом сетевом устройстве, и, наконец, поднята до соответствующего уровня на другом сетевом устройстве. Теперь более детально рассмотрим назначение каждого уровня.

***Физический уровень.*** На этом уровне обеспечивается непосредственно передача неструктурированного потока двоичной информации. для передачи используется конкретная физическая среда (кабель, радиоволны и т.п.). на данном уровне декларируется стандартизация сигналов и соединений. 

***Канальный уровень*** (или уровень передачи данных). На этом уровне решаются задачи обеспечения передачи данных по физической линии, обеспечения доступности физической линии, обеспечения синхронизации (например, передающего и принимающего узлов), а также задачи по борьбе с ошибками. Канальный уровень манипулирует порциями данных, которые называются кадрами. В кадрах присутствует избыточная информация для фиксации и устранения ошибок. Таким образом, основная задача канального уровня – обеспечение надёжной линии связи. На канальном уровне также может решаться задача внутренней адресации устройств в локальной сети. 

***Сетевой уровень.*** На этом уровне решаются задачи взаимодействия сетей: обеспечивается управление операциями сети (в т.ч. адресация абонентов, маршрутизация), а также обеспечивается связь между взаимодействующими сетевыми устройствами. Также на этом уровне происходит управление движением пакетов, и при необходимости поддерживается их буферизация. 

***Транспортный уровень.*** На данном уровне обеспечивается корректная транспортировка данных и взаимодействие между программой-отправителем и программой-получателем данных, т.е. обеспечивается программное взаимодействие (а не взаимодействие устройств). На этом же уровне принимается решение о выборе типа транспортных услуг (транспортировка данных с установлением виртуального канала или же без оного). В случае установления виртуального канала осуществляется контроль за фактом доставки и обработка ошибок (при этом взаимодействие программы-отправителя и программы- получателя обеспечивается в терминах сообщений). Если же виртуальный канал не устанавливается, то уровень не несет ответственности за доставку пакетов. На транспортном уровне может обеспечиваться выявление и исправление ошибок при передаче. 

***Сеансовый уровень.*** Этот уровень обеспечивает управление сеансами связи. На этом уровне решаются задачи определения активной стороны, подтверждения полномочий и паролей, а также решаются задачи организации меток, или контрольных точек по сеансу, которые отражают состояние сеанса связи и позволяют в случае возникновения сбоя восстанавливать сеанс с последней контрольной точки (т.е. повторять передачу не с начала, а с последней установленной контрольной точки). 

***Уровень представления данных*** обеспечивает унификацию используемых в сети кодировок и форматов передаваемых данных. 

***Прикладной уровень*** (уровень прикладных программ). На этом уровне формализуются правила взаимодействия с прикладными системами (например, с веб-браузером). Ради этого уровня выстраивается вся структура организации сетевого взаимодействия.

$$Всё,\ мчим\ дальше\ по\ материалу$$

## Локальные сети

Основные собенности `LAN`:
 + Географическая область охвата невелика (здание или несколько зданий);
 + Высокая скорость передачи (100-1000 `Mbps`);
 + Малая вероятность ошибок передачи.

Отсюда следует, что большие накладные расходы, свойственные многоуровневой модели `ISO/OSI`,для `LAN` не нужны, в нём применяются более простые протоколы.


# Аппаратная и программная составляющие обмена сообщениями между прикладными процессами

Рассматривая многопроцессорные системы с распределённой памятью, как частный случай локальной сети, можно применять известные сетевые технологии для спецификации протоколов взаимодействия системы, однако мы стремимся не только настроить разделение и разнесение вычислительной нагрузки, но и организовать именно **распараллеливание** и **единовременное взаимодействие** его частей посредством передачи сообщений.

В середине 80-х годов английская фирма `Inmos` выпустила миникомпьютер, названный **транспьютером**. Его отличительной особенностью является наличие 8-ми каналов (4 входные и 4 выходные) для обмена информацией с другими транспьютерами или другими устройствами, такими как диски, терминалы и т.п. 

```
Решетка транспьютеров, в которой каждый транспьютер параллельно с вычислениями может обмениваться одновременно по 8 каналам с 4 соседями, является хорошим примером, для которого будут формулироваться различные экзаменационные задачи. 
```

Для передачи информации между двумя соседними (связанными одним каналом) узлами транспьютерной матрицы первый узел должен выдать **операцию послать сообщение**, а второй – **операцию принять сообщение**. При этом заданная в операции приема область памяти должна быть по размеру не меньше передаваемого сообщения. Операции посылки и приема сообщения завершаются только после полного завершения передачи сообщения. 

Время передачи сообщения между двумя соседними узлами транспьютерной матрицы определяется двумя характеристиками аппаратуры - **временем старта передачи** $T_s$ и **временем передачи одного байта информации** соседнему узлу $T_b.$ При этом процессорные операции, включая чтение из памяти и запись в память, считаются бесконечно быстрыми. За время $T_s+T_b$ транспьютер может **передать 1 байт информации своим четырем соседям** и **принять от них 4 байта информации** (по одному байту от каждого). Для этого необходимо запустить на нем 8 служебных процессов. Для ускорения передачи сообщений используются **конвейеризация** (разбиение сообщения на кванты, чтобы воспользоваться параллельной работой каналов вдоль маршрута передачи) и **параллельное использование нескольких маршрутов**.

При обмене собщениями ключевыми параметрами функций приёма-передачи являются **адрес получателя/отправителя**, **адрес памяти** отправляемого/получаемого сообщения, а также **его длина**. \
Адресом может выступать физический или логический номер процессора, уникальный идентификатор динамически создаваемого процесса, кроме этогоможет указываться тэг, описывающий службу поиска имён (сервер имён
или широковещание - `broadcasting`).\
Конвейеризация передачи сообщений обеспечивается за счёт тройного копирования данных при пересылке - из памяти процесса-отправителя в буфер ОС на своем компьютере, между буферами ОС, из буфера ОС получателя в память процесса-получателя.\
Сами `send-receive` обладают дополнительными синхронизационными и конвейеризирующими свойствами:
 + Блокирующие (**до освобождения памяти с данными** или **до завершения фактической передачи**) и неблокирующие операции `send`;
 + Буферизуемые и небуферизуемые (`rendezvous` - переотправка до получения - или **с потерей информации при отсутствиии `receive`**) приёмы данных
 + Надёжная и ненадёжная передача данных

# `MPI` - `Message-Passing Interface`

`MPI` (05/05/1994 - ...)- это стандарт взаимодействия процессов путём передачи сообщений, обеспечивающий возможнсть эффективных коммуникаций процессов.

Основные цели разработки `MPI`:
 + **Создать интерфейс прикладного программирования** (не только для компиляторов или библиотек реализации систем);
 + **Обеспечить возможность эффективных коммуникаций** (избежать копирования из памяти в память, позволить совмещение вычислений и коммуникаций или разгрузку на коммуникационный процессор там, где он есть);
 + **Разрешить расширения** для использования в гетерогенной среде;
 + **Исходить из надежности коммуникаций** (пользователь не должен бороться с коммуникационными сбоями - это дело коммуникационных подсистем нижнего уровня);
 + Определить интерфейс, который бы **не слишком отличался от используемых** в то время, таких как `PVM`, `Express`, `P4`, и пр.;
 + Определить интерфейс, который мог бы **быстро быть реализован на многих продаваемых платформах** без серьезной переделки коммуникационного и системного ПО.

`MPI` включает в себя множество протоколов и функций для **коммуникации точка-точка**, **коллективных операций** приёма-передачи, позволяет создавать **группы процессов** и поддерживать **коммуникационные контексты** и **топологии процессов**, а, главное, обеспечивает простое создание процессов для модели `SPMD` (`Single Program - Multiple Data`, одна программа
используется для обработки разных данных на разных процессорах). \
При этом явных операций с разделяемой памятью и явной поддержки процессов с общей памятью (нитей, в частности) `MPI` не обспечивает. Кроме того, в нём отсутствуют вспомогательные функции типа таймеров, и операции, которые требуют больше поддержки от операционных систем,
чем действующие в настоящее время стандарты на ОС (например, получение
сообщений через механизм прерываний, активные сообщения).

Для небольшого погружения в работу `MPI` (для подробного изучения возможностей интерфейса можно воспользоваться )